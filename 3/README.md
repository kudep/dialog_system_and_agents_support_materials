## 3. Реализация и сервинг отдельных сервисов
- Использование сервинга на основе специализированных фреймворков:
  - Фреймворки обучения: TorchServe.
  - Фреймворки инференса: LangServe.
  - Фреймворки масштабного сервинга: Ray.
- Рекомендации по реализации:
  - Код-стайл и поддержка читаемости.
  - Покрытие тестами.
  - Унифицированный интерфейс.
  - Организация общих пакетов:
    - Через отдельный репозиторий.
    - Публикация на PyPI.
    - Хранение в одном репозитории (монорепозиторий).
    - Дублирование кода (как допустимый вариант).

### Использование сервинга на основе специализированных фреймворков

#### 1. Фреймворки обучения: TorchServe
TorchServe — это инструмент, который упрощает деплой моделей, обученных на PyTorch. Он используется для подготовки и развертывания моделей в продакшн-окружении.

Преимущества:
- Оптимизирован для работы с моделями PyTorch.
- Удобный API для экспорта моделей и настройки их сервинга.
- Поддержка масштабирования и управления версиями моделей.
- Интеграция с популярными библиотеками для обработки данных и метрик.

Кому подходит:
- Если проект использует PyTorch и требует быстрого развертывания моделей без сложной инфраструктуры.

---

#### 2. Фреймворки инференса: LangServe
LangServe предназначен для развертывания языковых моделей и работы с задачами NLP.

Преимущества:
- Оптимизация инференса для языковых моделей.
- Поддержка унифицированных интерфейсов и стандартов API.
- Упрощенная интеграция с различными модульными компонентами NLP (например, обработка текста, токенизация).

Кому подходит:
- Если требуется сервинг языковых моделей, особенно в сложных системах, где важно поддерживать высокий уровень взаимодействия между компонентами.

---

#### 3. Фреймворки масштабного сервинга: Ray
Ray — это распределённая система, предназначенная для работы с большими нагрузками.

Преимущества:
- Возможность масштабирования на кластеры и управления вычислениями.
- Поддержка параллельного исполнения задач, обработки потоков данных и управления состоянием.
- Интеграция с ML-фреймворками, такими как PyTorch, TensorFlow и Hugging Face.
- Подходит как для экспериментов, так и для продакшн-нагрузок.

Кому подходит:
- Если система должна обслуживать множество запросов одновременно, работать с распределенными данными или поддерживать динамическое масштабирование.

---

### Рекомендации по реализации

#### 1. Код-стайл и поддержка читаемости
Соблюдение стандартов код-стайла (например, PEP 8 для Python) помогает обеспечить высокую читаемость и лёгкость поддержки. Хорошо структурированный код упрощает онбординг новых разработчиков и предотвращает появление багов.

#### 2. Покрытие тестами
Тестирование (юнит-, интеграционные и e2e-тесты) снижает вероятность ошибок в коде, упрощает внесение изменений и гарантирует стабильную работу сервиса даже после обновлений.

#### 3. Унифицированный интерфейс
Использование единого стандарта API (например, REST или gRPC) для всех сервисов упрощает интеграцию между компонентами системы и делает архитектуру более понятной для разработчиков.

---

### Организация общих пакетов

#### 1. Через отдельный репозиторий
Преимущества:
- Упрощённое управление версиями и зависимостями.
- Лёгкость использования пакета в разных проектах.
Недостатки:
- Увеличение сложности поддержки и синхронизации версий.

#### 2. Публикация на PyPI
Преимущества:
- Удобство установки и обновления через стандартные инструменты (pip).
- Подходит для внутренних и внешних библиотек.
Недостатки:
- Требуется настройка публикации и соблюдение правил версионирования.

#### 3. Хранение в одном репозитории (монорепозиторий)
Преимущества:
- Все компоненты системы синхронизированы по версиям.
- Упрощение управления зависимостями в пределах одной команды.
Недостатки:
- Трудности масштабирования, если репозиторий становится слишком большим.

#### 4. Дублирование кода
Преимущества:
- Простой и быстрый подход, особенно для небольших проектов.
- Отсутствие зависимости от внешних библиотек.
Недостатки:
- Усложнение поддержки и внесения изменений при масштабировании.